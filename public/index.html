<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<title>Dark Chat with Calls & Upload</title>
<style>
  body {
    background: #121212;
    color: #eee;
    font-family: Arial, sans-serif;
    max-width: 700px;
    margin: 30px auto;
    padding: 0 15px;
  }
  #loginPage, #chatPage {
    display: none;
  }
  #loginPage.active, #chatPage.active {
    display: block;
  }
  #loginPage {
    text-align: center;
    margin-top: 120px;
  }
  input, button, textarea {
    font-size: 16px;
    border-radius: 5px;
    border: none;
  }
  input, textarea {
    padding: 10px;
    width: 100%;
    margin-bottom: 10px;
    background: #222;
    color: #eee;
  }
  button {
    cursor: pointer;
    background: #1a73e8;
    color: white;
    padding: 10px 20px;
    margin-bottom: 10px;
  }
  button:hover {
    background: #155ab6;
  }
  #usersOnline {
    margin-bottom: 15px;
  }
  #messages {
    background: #1e1e1e;
    height: 350px;
    overflow-y: auto;
    padding: 10px;
    border-radius: 5px;
    margin-bottom: 10px;
  }
  .message {
    margin-bottom: 12px;
    border-bottom: 1px solid #333;
    padding-bottom: 5px;
  }
  .message .author {
    font-weight: bold;
    color: #8ab4f8;
  }
  .message .text {
    margin: 4px 0;
  }
  .message .seen {
    font-size: 11px;
    color: #888;
  }
  #sendForm {
    display: flex;
    gap: 10px;
  }
  #messageInput {
    flex-grow: 1;
    padding: 10px;
    background: #222;
    color: #eee;
  }
  #fileInput {
    display: none;
  }
  #callBtn, #hangupBtn, #screenShareBtn {
    background: #28a745;
    margin-left: 10px;
  }
  #hangupBtn {
    background: #dc3545;
  }
  video {
    max-width: 100%;
    border-radius: 5px;
    margin-top: 10px;
  }
</style>
</head>
<body>

<div id="loginPage" class="active">
  <h2>Welcome to Dark Chat</h2>
  <input id="usernameInput" placeholder="Enter your username (Galaad or Skull)" />
  <button id="loginBtn">Log In</button>
</div>

<div id="chatPage">
  <h2>Chat Room</h2>
  <div><strong>Users online:</strong> <span id="usersOnline"></span></div>
  <div id="messages"></div>

  <form id="sendForm">
    <input id="messageInput" autocomplete="off" placeholder="Type a message..." />
    <button type="submit">Send</button>
    <button type="button" id="uploadBtn">ðŸ“Ž</button>
    <input type="file" id="fileInput" accept="image/*,video/*,image/gif" />
  </form>

  <div style="margin-top:15px;">
    <button id="callBtn">Start Call</button>
    <button id="screenShareBtn">Share Screen</button>
    <button id="hangupBtn" style="display:none;">Hang Up</button>
  </div>

  <video id="localVideo" autoplay muted></video>
  <video id="remoteVideo" autoplay></video>
</div>

<script src="/socket.io/socket.io.js"></script>
<script src="https://cdn.jsdelivr.net/npm/simple-peer@9/simplepeer.min.js"></script>
<script>
  const socket = io();

  const loginPage = document.getElementById('loginPage');
  const chatPage = document.getElementById('chatPage');
  const usernameInput = document.getElementById('usernameInput');
  const loginBtn = document.getElementById('loginBtn');
  const usersOnlineSpan = document.getElementById('usersOnline');
  const messagesDiv = document.getElementById('messages');
  const sendForm = document.getElementById('sendForm');
  const messageInput = document.getElementById('messageInput');
  const uploadBtn = document.getElementById('uploadBtn');
  const fileInput = document.getElementById('fileInput');
  const callBtn = document.getElementById('callBtn');
  const hangupBtn = document.getElementById('hangupBtn');
  const screenShareBtn = document.getElementById('screenShareBtn');
  const localVideo = document.getElementById('localVideo');
  const remoteVideo = document.getElementById('remoteVideo');

  let username = null;
  const validUsernames = ['Galaad', 'Skull'];
  let peer = null;
  let localStream = null;
  let isScreenSharing = false;
  let mySocketID = null;

  loginBtn.onclick = () => {
    const entered = usernameInput.value.trim();
    if (!validUsernames.includes(entered)) {
      alert('Wrong username. Use Galaad or Skull');
      return;
    }
    username = entered;
    socket.emit('login', username);
    loginPage.classList.remove('active');
    chatPage.classList.add('active');
    messageInput.focus();
  };

  socket.on('yourID', (id) => {
    mySocketID = id;
  });

  socket.on('usersOnline', (list) => {
    usersOnlineSpan.textContent = list.join(', ');
  });

  socket.on('history', (msgs) => {
    msgs.forEach(addMessage);
  });

  socket.on('message', (msg) => {
    addMessage(msg);
    if (!msg.seenBy.includes(username)) {
      socket.emit('messageSeen', { messageId: msg.id, username });
    }
  });

  socket.on('messageSeenUpdate', ({ messageId, seenBy }) => {
    const seenSpan = document.querySelector(`#msg-${messageId} .seen`);
    if (seenSpan) {
      seenSpan.textContent = 'Seen by: ' + seenBy.join(', ');
    }
  });

  sendForm.onsubmit = e => {
    e.preventDefault();
    const text = messageInput.value.trim();
    if (!text) return;
    socket.emit('message', { author: username, text });
    messageInput.value = '';
  };

  uploadBtn.onclick = () => fileInput.click();

  fileInput.onchange = () => {
    const file = fileInput.files[0];
    if (!file) return;

    const formData = new FormData();
    formData.append('file', file);

    fetch('/upload', {
      method: 'POST',
      body: formData,
    })
      .then(res => res.json())
      .then(data => {
        let msgText = '';
        if (file.type.startsWith('image/') || file.type === 'image/gif') {
          msgText = `<img src="${data.url}" style="max-width:200px; border-radius:5px;" />`;
        } else if (file.type.startsWith('video/')) {
          msgText = `<video controls src="${data.url}" style="max-width:200px; border-radius:5px;"></video>`;
        } else {
          msgText = `<a href="${data.url}" target="_blank">Download file</a>`;
        }
        socket.emit('message', { author: username, text: msgText });
      })
      .catch(() => alert('Upload failed'));

    fileInput.value = '';
  };

  // Messages display function
  function addMessage(msg) {
    const div = document.createElement('div');
    div.className = 'message';
    div.id = 'msg-' + msg.id;
    div.innerHTML = `
      <div class="author">${escapeHtml(msg.author)}</div>
      <div class="text">${msg.text}</div>
      <div class="seen">Seen by: ${msg.seenBy.join(', ')}</div>
    `;
    messagesDiv.appendChild(div);
    messagesDiv.scrollTop = messagesDiv.scrollHeight;
  }

  function escapeHtml(text) {
    if (!text) return '';
    return text.replace(/[&<>"']/g, (m) => {
      return {
        '&': '&amp;',
        '<': '&lt;',
        '>': '&gt;',
        '"': '&quot;',
        "'": '&#39;',
      }[m];
    });
  }

  // --- WebRTC Call & Screen Share Logic ---

  function startCall(screenShare = false) {
    if (peer) {
      alert('Call already in progress');
      return;
    }
    navigator.mediaDevices.getUserMedia({
      video: true,
      audio: true
    }).then(stream => {
      if (screenShare) {
        navigator.mediaDevices.getDisplayMedia({ video: true }).then(screenStream => {
          localStream = screenStream;
          setupPeer(stream, screenStream);
        }).catch(err => {
          alert('Screen sharing denied');
          localStream = stream;
          setupPeer(stream);
        });
      } else {
        localStream = stream;
        setupPeer(stream);
      }
    }).catch(() => alert('Could not get media'));
  }

  function setupPeer(camStream, screenStream) {
    peer = new SimplePeer({
      initiator: true,
      trickle: false,
      stream: screenStream || camStream
    });

    localVideo.srcObject = screenStream || camStream;
    localVideo.play();

    peer.on('signal', data => {
      // Find the first other user to call
      socket.emit('callUser', { to: findOtherUserID(), signal: data });
    });

    peer.on('stream', remoteStream => {
      remoteVideo.srcObject = remoteStream;
      remoteVideo.play();
    });

    peer.on('close', endCall);
    peer.on('error', endCall);

    hangupBtn.style.display = 'inline-block';
  }

  function findOtherUserID() {
    // Simple: pick first user in online list who is not me
    const users = usersOnlineSpan.textContent.split(', ').filter(u => u && u !== username);
    // We donâ€™t have direct socket IDs of others, so assume only 2 users max
    // We'll need a mapping server-side for real, but simplified here:
    return null; // Can't implement well without mapping, needs extra backend work
  }

  socket.on('incomingCall', ({ from, signal }) => {
    if (peer) {
      socket.emit('rejectCall', from);
      return;
    }
    if (!confirm(`${from} is calling you. Accept?`)) {
      socket.emit('rejectCall', from);
      return;
    }

    navigator.mediaDevices.getUserMedia({ video:true, audio:true })
      .then(stream => {
        localStream = stream;
        peer = new SimplePeer({ initiator: false, trickle: false, stream });
        localVideo.srcObject = stream;
        localVideo.play();

        peer.on('signal', data => {
          socket.emit('answerCall', { to: from, signal: data });
        });
        peer.on('stream', remoteStream => {
          remoteVideo.srcObject = remoteStream;
          remoteVideo.play();
        });
        peer.on('close', endCall);
        peer.on('error', endCall);

        peer.signal(signal);
        hangupBtn.style.display = 'inline-block';
      })
      .catch(() => alert('Could not get media'));
  });

  socket.on('callAnswered', signal => {
    peer.signal(signal);
  });

  socket.on('callRejected', () => {
    alert('Call rejected');
    endCall();
  });

  socket.on('callDisconnected', () => {
    alert('Call ended');
    endCall();
  });

  callBtn.onclick = () => startCall(false);
  screenShareBtn.onclick = () => startCall(true);

  hangupBtn.onclick = () => {
    if (peer) {
      peer.destroy();
      socket.emit('disconnectCall', findOtherUserID());
      endCall();
    }
  };

  function endCall() {
    if (localStream) {
      localStream.getTracks().forEach(t => t.stop());
      localStream = null;
    }
    if (peer) {
      peer.destroy();
      peer = null;
    }
    localVideo.srcObject = null;
    remoteVideo.srcObject = null;
    hangupBtn.style.display = 'none';
  }
</script>

</body>
</html>
